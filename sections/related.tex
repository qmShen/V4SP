\section{Related work}
\subsection{Visual Analysis for Database Queries}
%Understanding the query behavior and evaluating database performance has been studied for decades since the database management systems(DBMSs) have been found. Both database and visualization communities have proposed methods to analyze the performance and diagnose the queries automatically or manually. We give a brief introduction about the related works from the two following aspects: \textit{query logic structure} and \textit{query execution structure}, and refer the interested readers to~\cite{gathani2020debugging} for the systematic overview about the database query debug and performance analysis.


%Understanding query performance has long been studied since the advent of database management systems (DBMSs). 

Both the database and visualization communities have proposed methods to analyze query performance and diagnose performance problems manually or automatically. We briefly review related works on \textit{understanding query logic} and \textit{analyzing query execution plan}, and refer the interested readers to~\cite{gathani2020debugging} for a systematic survey on database query debugging and performance analysis.

%\emph{\textbf{Analyzing query structure}}. Queries such as SQL sentences can be hard to read since they always have a deep and nested structure. Many research works have been conducted to help the database users to understand the quires quickly. The most common method is to utilize visualization techniques to show the logic structure of operations[all]. For example, extended from previous work, QueryVis uses the node-link diagrams to show the relationship between operators; the unambiguity is also proved in this paper. Other than visualization, Gawade et al. proposed a method to translate a query to Natural Language.  


\emph{\textbf{Understand query logic}}. Query specifications in high-level languages such as SQL can be difficult to read as they may have deep and nested structures. Many research works have tried to provide an intuitive understanding of the query logic~\cite{abouzied2012dataplay, gatterbauer2011databases, cerullo2007system,jaakkola2003visual,leventidis2020queryvis,danaparamita2011queryviz}. 
The most common way is to leverage visualization techniques to assist query understanding.
For example, GraphSQL~\cite{cerullo2007system} and Visual SQL~\cite{jaakkola2003visual} propose visual query languages, which support query visualization and interactive query tuning.
QueryVis~\cite{leventidis2020queryvis} uses a node-link diagram to show the relation among the operators and proves that node-link diagram can expresses queries without ambiguity. Besides visualization, Gawade et al.~\cite{koutrika2010explaining} proposed a method to translate a query into its descriptions in natural language. 
%\textit{Only two related works are discussed; try to add more} 

\emph{\textbf{Analyze query execution plan}}. As introduced before, (distributed) database systems first generate a logical execution plan for a query and then execute physical tasks according to the plan. Understanding how the logical plan is executed can enable users to reason query performance. Many industrial softwares (e.g., Tez UI, \textit{xxx} and \textit{\textbf{xxx}}) visualize the query execution process at the operator level~\cite{tez-ui}. They use tree or directed acyclic graph (DAG) to show the relation among the operators and adopt the Gantt chart to visualize the execution progress. For example, VQA~\cite{simitsis2014vqa} displays the logical query plan as a tree with nodes indicating operators and edges indicating dataflow. Bar charts are inserted in the nodes to show the execution statistics of the operators (e.g., execution time, memory allocated). Perfopticon~\cite{moritz2015perfopticon} provides separate views for the logical query plan, overall execution progress, and system performance statistics. It also allows users to observe the execution statistics of the operators on different workers and can help identify performance problems such as slow workers and data skew. 

Existing works analyze query execution at the \textit{operator level} at best while our $\DQV$ analyzes query execution at the more fine-grained task level. As task is the minimum (i.e., atom) execution unit in Hive, tracking task execution allows to accurately identify the causes of errors and performance problems. For instance, data skew can be observed by profiling the size of data processed by the tasks, query bottleneck can be analyzed by checking the tasks that block the data dependencies, and network or memory problems can be identified by measuring the resource consumption of the tasks. As an operator corresponds to many tasks across the machines, it is difficult to gain such fine-grained insights on the operator level. However, the large number of tasks and their complex dependencies make task-level execution visualization more challenging than operator-level visualization.


% \textit{why we need it? an example application that can not be solved by perfopticon? what makes it challenging?}

%\emph{\textbf{Analyze query plan}}. 
%After a query is issued by the database users, the query will be optimized and executed on the database platforms. Especially for the distributed database system, the query will be translated into the logic execution plans, which are used to generating the physical tasks. Understanding the execution plans is important for users to expect the query performance. Many existing industrial softwares are developed to visualize the query execution process~\cite{tez-ui}. These softwares always utilize the Gantt chart to show the progress and use tree or directed acyclic graph(DAG) to show the relationship among the operators. VQA~\cite{simitsis2014vqa} displays the logic of the query plan as a tree with the nodes indicating operators and the edge indicating the dataflow. Barcharts are inserted into the node to show the metric of the operator(e.g., execution time, memory allocated). Another work highly related to our is Perfopticon~\cite{moritz2015perfopticon}, which designs a visual analytics system consisting of coordinated views to visualize the query plan, the overall query execution data flow and execution trace. The system allows users to observe the execution trace of fragments or operators on different workers and can help the database users successfully identify the query problems such as data skew, incorrect hashing, etc. 

%Our work is highly motivated by Perfopticon and performs the finer-grained level of exploration: the task level, which can identify the abnormal query behavior more precisely. Compare with Perforpticon, our system also consider the physical system performance metrics in our visual design to help users to reason the query execution.





\subsection{Visualization for Sequence Data}

%The query execution records in the distributed database system can be represented by even sequence data.
%As a special type of time-series data, event sequence record a series of discrete events in the time order of occurrence~\cite{guo2020survey}. 
%Nowadays, researchers have studied the sequence data visualization techniques as applied to various applications such as health care~\cite{malik2015cohort, wongsuphasawat2011outflow}, social media~\cite{zhao2014fluxflow, law2018maqui}, and education~\cite{chen2015peakvizor, mu2019moocad, goulden2019ccvis, he2019vuc, chen2018viseq}.
%For the detailed taxonomy about the time-series and event sequence visualization, we refer the readers to read the surveys~\cite{guo2020survey, silva2000visualization}. 
%
%
%Sequence visualization is designed to reveal the information of events such as the event type, start time, end time and duration. Moreover, for the complex application requirement, various visualization tasks are proposed, such as visual summarization, prediction $\&$ recommendation, anomaly analysis and comparison. Existing visualization techniques can be classified into five categories according to the form of visual representations, i.e., \emph{sankey-based visualization}, \emph{hierarchy-based visualizations}, \emph{chart-based visualizations}, \emph{timeline-based visualizations} and \emph{matrix-based visualizations}~\cite{guo2020survey}. 

Query execution in distributed databases can be described by a sequence of events, e.g., the start, execution and finish of tasks on the machines, and thus we review related works on sequence data visualization in this part. As a special type of time-series data, event sequence is defined as a series of discrete events recorded in the time order of their occurrences~\cite{guo2020survey}. Sequence data is ubiquitous in many fields such as health care~\cite{malik2015cohort, wongsuphasawat2011outflow}, social media~\cite{zhao2014fluxflow, law2018maqui}, and education~\cite{chen2015peakvizor, mu2019moocad, goulden2019ccvis, he2019vuc, chen2018viseq}. Sequence visualization aims to show the information of the events such as the event type, start time, end time and duration. For specific visualization applications, various tasks are proposed, such as visual summarization, prediction $\&$ recommendation, anomaly detection and comparison. Existing sequence visualization techniques can be classified into five categories according to their form of visual representations, i.e., \emph{sankey-based visualization}, \emph{hierarchy-based visualizations}, \emph{chart-based visualizations}, \emph{timeline-based visualizations} and \emph{matrix-based visualizations}~\cite{guo2020survey}. We briefly introduce them below and refer the readers to related surveys~\cite{guo2020survey, silva2000visualization} for more detailed discussions on time-series and event sequence visualization. 



\emph{\textbf{Sankey-based, hierarchy-based and matrix-based visualizations}} display an event sequence after mapping it to special structures such as graph or tree.
For example, LifeFlow~\cite{wongsuphasawat2011lifeflow} utilizes the tree structure to summarize an event sequence, in which a node represents a group of events. Outflow~\cite{wongsuphasawat2011outflow} models the progression paths of an event sequence as a DAG with a node indicating a cluster of states, and visualizes the DAG as a Sankey diagram~\cite{riehmann2005interactive}. These methods provide high-level summarization for an event sequences and cannot show the detailed information of each event. Matrixwave~\cite{zhao2015matrixwave} utilizes a sequence of matrices to visualize the dependencies among the events. However, it does not show the detailed temporal information of the events and cannot scale to long event sequence. 

\emph{\textbf{Chart-based visualizations}} uses barchart, linechart or scatter plot to visualize the trend or distribution of the events, which provides assisting views to support interactive explorations. For instance, barchart and linechart are used to show the distribution of the attributes in the event sequence over time~\cite{gotz2019visual, cappers2017exploring}. Scatter plot has been used to provide a coarse overview of an event sequence or some sequence groups by projecting them to the 2D canvas using dimension reduction techniques or two chosen attributes~\cite{wu2020visual, malik2016high, gotz2019visual}. In addition to the distribution of the events, scatter plot has also been used to identify outliers~\cite{}. 

\emph{\textbf{Timeline-based visualizations}} are recognized as the most intuitive way to demonstrate events in their time order. Specifically, the Gantt chart directly shows the temporal information of the events, including start time, end time and duration. Many industrial tools such as Tez UI, xxx and xxx use the Gantt chart to demonstrate the execution progress~\cite{}. For example, Lifeline~\cite{plaisant1996lifelines} uses the Gantt chart to display event sequences and the individual events in the sequences, and each sequence takes a single row. LiveGantt~\cite{jo2014livegantt} proposes an algorithm to improve scalability for visualizing scheduling events. However, these methods cannot be directly used for understanding query execution as the dependencies among the events are ignored. In addition, the Gantt chart suffers from poor scalability when applied to a large number of events and makes it difficult to identify abnormal events without proper alignment.
