\section{Related work}
\subsection{Query Analysis}
%Understanding the query behavior and evaluating database performance has been studied for decades since the database management systems(DBMSs) have been found. Both database and visualization communities have proposed methods to analyze the performance and diagnose the queries automatically or manually. We give a brief introduction about the related works from the two following aspects: \textit{query logic structure} and \textit{query execution structure}, and refer the interested readers to~\cite{gathani2020debugging} for the systematic overview about the database query debug and performance analysis.


%Understanding query performance has long been studied since the advent of database management systems (DBMSs). 

Both the database and visualization communities have proposed methods to analyze query performance and diagnose performance problems manually or automatically. We briefly review related works on \textit{understanding query logic} and \textit{analyzing query execution plan}, and refer the interested readers to~\cite{gathani2020debugging} for a systematic survey on database query debugging and performance analysis.

%\emph{\textbf{Analyzing query structure}}. Queries such as SQL sentences can be hard to read since they always have a deep and nested structure. Many research works have been conducted to help the database users to understand the quires quickly. The most common method is to utilize visualization techniques to show the logic structure of operations[all]. For example, extended from previous work, QueryVis uses the node-link diagrams to show the relationship between operators; the unambiguity is also proved in this paper. Other than visualization, Gawade et al. proposed a method to translate a query to Natural Language.  


\emph{\textbf{Understand query logic}}. Query specifications in high-level languages such as SQL can be difficult to read as they may have deep and nested structures. Many research works have tried to provide an intuitive understanding of the query logic~\cite{abouzied2012dataplay, gatterbauer2011databases, cerullo2007system,jaakkola2003visual,leventidis2020queryvis,danaparamita2011queryviz}. 
The most common way is to leverage the visualization techniques to assistant the query operation.
For example, GraphSQL~\cite{cerullo2007system} and Visual SQL~\cite{jaakkola2003visual} propose visual query languages which support query visualization and interactive query tuning.
QueryVis~\cite{leventidis2020queryvis} uses a node-link diagram to show the relation among the operators and proves that node-link diagram can expresses queries without ambiguity. Besides visualization, Gawade et al.~\cite{koutrika2010explaining} proposed a method to translate a query into its description in natural language. 
\textit{Only two related works are discussed; try to add more} 

\emph{\textbf{Analyze query execution plan}}. As introduced before, (distributed) database systems first generate a logical execution plan for a query and then execute physical tasks according to the plan. Understanding how the logical plan is executed can enable users to reason query performance. Many industrial softwares (e.g., Tez UI, \textit{xxx} and \textit{\textbf{xxx}}) can visualize the query execution process at the operator level~\cite{tez-ui}. These use tree or directed acyclic graph (DAG) to show the relation among the operators and adopt the Gantt chart to visualize the execution progress. For example, VQA~\cite{simitsis2014vqa} displays the logical query plan as a tree with nodes indicating operators and edges indicating dataflow. Bar charts are inserted in the nodes to show the execution statistics of the operators (e.g., execution time, memory allocated). Perfopticon~\cite{moritz2015perfopticon} provides separate views for the logical query plan, overall execution progress and dataflow, and system performance statistics. It also allows users to observe the execution statistics of fragments or operators on different workers and can help the database users identify performance problems such as slow workers and data skew. 

\QM{Existing works analyze query execution on the \textit{operator level} at best while our $\DQV$ analyzes query execution on the more fine-grained task level. The task in Hadoop system is the atom process where any failure of the sub-process will result in the re-execution of a task.
Analyzing the task can help to perform precise diagnose of the query. For instance, we can identify the data skew problem by checking the size of data processed by the tasks or find the bottleneck by selecting and analyzing the slow-running tasks. 
However, the large task set and complex dependencies also bring challenges to perform analysis at the task level.}
% \textit{why we need it? an example application that can not be solved by perfopticon? what makes it challenging?}

%\emph{\textbf{Analyze query plan}}. 
%After a query is issued by the database users, the query will be optimized and executed on the database platforms. Especially for the distributed database system, the query will be translated into the logic execution plans, which are used to generating the physical tasks. Understanding the execution plans is important for users to expect the query performance. Many existing industrial softwares are developed to visualize the query execution process~\cite{tez-ui}. These softwares always utilize the Gantt chart to show the progress and use tree or directed acyclic graph(DAG) to show the relationship among the operators. VQA~\cite{simitsis2014vqa} displays the logic of the query plan as a tree with the nodes indicating operators and the edge indicating the dataflow. Barcharts are inserted into the node to show the metric of the operator(e.g., execution time, memory allocated). Another work highly related to our is Perfopticon~\cite{moritz2015perfopticon}, which designs a visual analytics system consisting of coordinated views to visualize the query plan, the overall query execution data flow and execution trace. The system allows users to observe the execution trace of fragments or operators on different workers and can help the database users successfully identify the query problems such as data skew, incorrect hashing, etc. 

%Our work is highly motivated by Perfopticon and performs the finer-grained level of exploration: the task level, which can identify the abnormal query behavior more precisely. Compare with Perforpticon, our system also consider the physical system performance metrics in our visual design to help users to reason the query execution.





\subsection{Visualization for Sequence Data}
The query execution records in the distributed database system can be represented by even sequence data.
As a special type of time-series data, event sequence record a series of discrete events in the time order of occurence~\cite{guo2020survey}. 
Nowadays, researchers have studied the sequence data visualization techniques as applied to various applications such as health care~\cite{malik2015cohort, wongsuphasawat2011outflow}, social media~\cite{zhao2014fluxflow, law2018maqui}, and education~\cite{chen2015peakvizor, mu2019moocad, goulden2019ccvis, he2019vuc, chen2018viseq}.
For the detailed taxonomy about the time-series and event sequence visualization, we refer the readers to read the surveys~\cite{guo2020survey, silva2000visualization}. 


Sequence visualization is designed to reveal the information of events such as the event type, start time, end time and duration. Moreover, for the complex application requirement, various visualization tasks are proposed, such as visual summarization, prediction $\&$ recommendation, anomaly analysis and comparison. Existing visualization techniques can be classified into five categories according to the form of visual representations, i.e., \emph{sankey-based visualization}, \emph{hierarchy-based visualizations}, \emph{chart-based visualizations}, \emph{timeline-based visualizations} and \emph{matrix-based visualizations}~\cite{guo2020survey}. 

\emph{\textbf{Hierarchy-based visualizations}}~\cite{gotz2019visual}, \emph{\textbf{sankey-based visualizations}} and \emph{\textbf{matrix-based visualizatios}} are always designed for displaying the sequence or sequence collection after modeling the them as special structures such as graph or tree.
For example, LifeFlow~\cite{wongsuphasawat2011lifeflow} utilizes the tree structure with a node presenting a group of events to summarize the sequences. Outflow~\cite{wongsuphasawat2011outflow} models the progression paths of sequences as directed acyclic graph with a node indicating a cluster of states, and then visualize the graph as Sankey diagram~\cite{riehmann2005interactive}.  These methods always provide the highly abstract summarization for sequences and cannot directly reveal the pattern of specific individual sequence. Matrixwave~\cite{zhao2015matrixwave} utilizes a sequence of matrixs to show the connections between specific events, which can provide details connecting information of sequence. However, Matrixwave loss the detailed temporal information and cannot be used for very large sequence collections. 

\emph{\textbf{Chart-based visualizations}} uses barchart, linechart or scatter plot to visualize the trend or distribution of events, which always works as assisting views to support the interactive explorations. For instance, barchart and linechart are always used to show the distribution of the attributes of sequences or temporal trends~\cite{gotz2019visual, cappers2017exploring}. Scatter plot can be used to show the overview of coarse-level overview of the sequence or sequence groups by projecting them to the 2D canvas through dimension reduction algorithms or two specific attributes~\cite{wu2020visual, malik2016high, gotz2019visual}. Other than the distribution of sequences, the scatter plot can also reveal the outliers. 

\emph{\textbf{Timeline-based visualizations}} are known as the most intuitive ways which demonstrate the events in time order. Gantt chart is a direct way to show the temporal information of event sequences, including the start time, end time and duration. Many industrial tools such as the Tez UI uses the Gantt diagram to clearly demonstrate the progress of the operations. Lifeline~\cite{plaisant1996lifelines} use Gantt diagram to display the sequence as well as the events and each sequence takes a single row. LiveGantt~\cite{jo2014livegantt} proposes an algorithm to visualize the scheduling events with better scalability. However, these methods cannot directly be used in our application since the dependencies of these sequences are ignored. Moreover, the Gantt chart also suffers the series scalability problem when applied it to a large sequence dataset, and the abnormal sequence will be hidden without alignment.
